% Created 2020-08-31 Mon 16:28
% Intended LaTeX compiler: pdflatex
\documentclass[11pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{graphicx}
\usepackage{grffile}
\usepackage{longtable}
\usepackage{wrapfig}
\usepackage{rotating}
\usepackage[normalem]{ulem}
\usepackage{amsmath}
\usepackage{textcomp}
\usepackage{amssymb}
\usepackage{capt-of}
\usepackage{hyperref}
\author{\href{http://ivandyachenko.io/}{Ivan Dyachenko}}
\date{\today}
\title{\href{https://codeforces.com/edu/course/2/lesson/2}{ITMO Academy. Suffix Array}}
\hypersetup{
 pdfauthor={\href{http://ivandyachenko.io/}{Ivan Dyachenko}},
 pdftitle={\href{https://codeforces.com/edu/course/2/lesson/2}{ITMO Academy. Suffix Array}},
 pdfkeywords={},
 pdfsubject={},
 pdfcreator={Emacs 27.1 (Org mode 9.3.7)}, 
 pdflang={English}}
\begin{document}

\maketitle
\tableofcontents


\section{Suffix array. Base algorithm}
\label{sec:org44b94b2}

\subsection{What is a suffix array?}
\label{sec:org2da6791}
Consider a string \(s\):
\begin{center}
\begin{tabular}{l}
s = "ababba"\\
\end{tabular}
\end{center}

Let's write all its suffixes in lexicographical order. We get this an array of strings:
\begin{center}
\begin{tabular}{l}
a\\
ababba\\
abba\\
ba\\
babba\\
bba\\
\end{tabular}
\end{center}

This sequence of suffixes is called the \textbf{suffix array}. How will we store it? If you store it as
strings, then it will occupy \(\mathcal{O}(n^2)\) memory. To keep it smaller, let's notice that the suffix can
be identified by the index of the first character. In our example, suffixes will have these
numbers:
\begin{center}
\begin{tabular}{rrrrrrr}
\textbf{a} & \textbf{b} & \textbf{a} & \textbf{b} & \textbf{b} & \textbf{a} & \\
\hline
0 & 1 & 2 & 3 & 4 & 5 & 6\\
\end{tabular}
\end{center}

\begin{center}
\begin{tabular}{ll}
\textbf{6} & \\
\textbf{5} & \texttt{a}\\
\textbf{0} & \texttt{ababba}\\
\textbf{2} & \texttt{abba}\\
\textbf{4} & \texttt{ba}\\
\textbf{1} & \texttt{babba}\\
\textbf{3} & \texttt{bba}\\
\textbf{p} & \\
\end{tabular}
\end{center}

We will store the suffix array as an array \(p\) of suffix numbers in sorted order. Then it will
occupy \(\mathcal{O}(n)\) memory. Now our first task is this: given the string \(s\), build an array \(p\).

To make the algorithm simpler, we will make some preparations. First, add the symbol \texttt{\$} to the
end of the string. This will be a special character that is smaller than all characters in the
string. As a result, the symbol \texttt{\$} will be added to each suffix. Let's notice that the order of
strings has not changed, because \texttt{\$} is smaller than all characters.
\begin{center}
\begin{tabular}{rrrrrrr}
\textbf{a} & \textbf{b} & \textbf{a} & \textbf{b} & \textbf{b} & \textbf{a} & \textbf{\$}\\
\hline
0 & 1 & 2 & 3 & 4 & 5 & 6\\
\end{tabular}
\end{center}

\begin{center}
\begin{tabular}{ll}
\textbf{6} & \texttt{\$}\\
\textbf{5} & \texttt{a\$}\\
\textbf{0} & \texttt{ababba\$}\\
\textbf{2} & \texttt{abba\$}\\
\textbf{4} & \texttt{ba\$}\\
\textbf{1} & \texttt{babba\$}\\
\textbf{3} & \texttt{bba\$}\\
\textbf{p} & \\
\end{tabular}
\end{center}

Now let's make the length of all the strings the same. To do this, let's write after \texttt{\$} all the
other characters in the string in a cycle. Again, note that order of the strings has not changed,
because the characters after \texttt{\$} do not affect the string ordering:
\begin{center}
\begin{tabular}{rrrrrrr}
\textbf{a} & \textbf{b} & \textbf{a} & \textbf{b} & \textbf{b} & \textbf{a} & \textbf{\$}\\
\hline
0 & 1 & 2 & 3 & 4 & 5 & 6\\
\end{tabular}
\end{center}

\begin{center}
\begin{tabular}{ll}
\textbf{6} & \texttt{\$ababba}\\
\textbf{5} & \texttt{a\$ababb}\\
\textbf{0} & \texttt{ababba\$}\\
\textbf{2} & \texttt{abba\$ab}\\
\textbf{4} & \texttt{ba\$abab}\\
\textbf{1} & \texttt{babba\$a}\\
\textbf{3} & \texttt{bba\$aba}\\
\textbf{p} & \\
\end{tabular}
\end{center}

Now the last preparation. Let's make the length of the strings the power of two, for this we add
more characters in a cycle until the length of the string becomes a power of two. In our example,
the string length is 7, so we need to add one character:
\begin{center}
\begin{tabular}{rrrrrrr}
\textbf{a} & \textbf{b} & \textbf{a} & \textbf{b} & \textbf{b} & \textbf{a} & \textbf{\$}\\
\hline
0 & 1 & 2 & 3 & 4 & 5 & 6\\
\end{tabular}
\end{center}

\begin{center}
\begin{tabular}{ll}
\textbf{6} & \texttt{\$ababba\$}\\
\textbf{5} & \texttt{a\$ababba}\\
\textbf{0} & \texttt{ababba\$a}\\
\textbf{2} & \texttt{abba\$aba}\\
\textbf{4} & \texttt{ba\$ababb}\\
\textbf{1} & \texttt{babba\$ab}\\
\textbf{3} & \texttt{bba\$abab}\\
\textbf{p} & \\
\end{tabular}
\end{center}

\subsection{Algorithm idea}
\label{sec:org84b1a6d}
We will build this table by columns, each time increasing the number of columns twice. That is,
first we construct the first column, then the first two, then four, and so on. In other words, we
divide the algorithm into \(\log n\) iterations, and on the iteration \(k\) we construct an array
consisting of the strings \(s[i..i + 2^k - 1]\), sorted in lexicographical order (we assume that
the string is cyclic, that is, the character with index \(i\) corresponds to the character with
index \(i \mod n\) of the original string).

\begin{center}
\begin{tabular}{llll}
k=0 & k=1 & k=2 & k=3\\
\hline
\textbf{6} \texttt{\$} & \textbf{6} \texttt{\$a} & \textbf{6} \texttt{\$aba} & \textbf{6} \texttt{\$ababba\$}\\
\textbf{0} \texttt{a} & \textbf{5} \texttt{a\$} & \textbf{5} \texttt{a\$ab} & \textbf{5} \texttt{a\$ababba}\\
\textbf{2} \texttt{a} & \textbf{0} \texttt{ab} & \textbf{0} \texttt{abab} & \textbf{0} \texttt{ababba\$a}\\
\textbf{5} \texttt{a} & \textbf{2} \texttt{ab} & \textbf{2} \texttt{abba} & \textbf{2} \texttt{abba\$aba}\\
\textbf{1} \texttt{b} & \textbf{1} \texttt{ba} & \textbf{4} \texttt{ba\$a} & \textbf{4} \texttt{ba\$ababb}\\
\textbf{3} \texttt{b} & \textbf{4} \texttt{ba} & \textbf{1} \texttt{babb} & \textbf{1} \texttt{babba\$ab}\\
\textbf{4} \texttt{b} & \textbf{3} \texttt{bb} & \textbf{3} \texttt{bba\$} & \textbf{3} \texttt{bba\$abab}\\
\end{tabular}
\end{center}

Let's start from the base, if \(k = 0\), then we need to sort the strings of one character
\(s[i..i]\). This can be done by any sort in \(\mathcal{O}(n \log n)\).

Now make the transition from \(k\) to \(k + 1\). We need to sort the strings of length \(2^{k + 1}\),
using the order of the strings of length \(2^k\). To do this, let's learn how to quickly compare
strings of length \(2^{k + 1}\). Suppose we have two strings \(A\) and \(B\), both have lengths \(2^{k +
   1}\). Let's divide both strings into two halves, then each half has a length \(2^k\).

Let's compare their left halves. If they are not equal, for example, if \(A.left\) is less than
\(B.left\). This means that they have some common prefix, and after it comes a character that is
not equal, and this character in the string \(A\) is less than in the string \(B\). In this case, the
entire string \(A\) is less than the string \(B\), and the right halves should not be compared.

If the left halves are equal, then let's compare the right halves. Suppose, for example, \(A.right\)
is less than \(B.right\). This again means that there is a common prefix, and then a character that
is less in the string \(A\) than in the string \(B\). Again we get that the string \(A\) is less than
the string \(B\).

Thus, we get that \(A < B \iff A.left < B.left \lor (A.left = B.left \land A.right < B.right)\). If we
learn to quickly compare strings of length \(2^k\), then we will make a comparator that quickly
compares strings of length \(2^{k + 1}\).

Now we need to learn how to compare strings of length \(2^k\) quickly. We will do it as
follows. Let's go through the strings of length \(2^k\) in sorted order, and assign them integer
numbers so that a smaller string corresponds to a smaller number. We call these numbers
\textbf{equivalence classes}. Now, instead of comparing strings, we will compare their equivalence
classes. Thus, we can compare strings of length \(2^{k + 1}\) in \(\mathcall{O}(1)\).

For example, for the string that we analyzed above, for \(k = 1\) we get the following order of
strings of length \(2\). Let's go through these strings assign them equivalence classes (array
\(c\)).

\begin{center}
\begin{tabular}{lll}
\textbf{6} & \texttt{\$a} & \textbf{0}\\
\textbf{5} & \texttt{a\$} & \textbf{1}\\
\textbf{0} & \texttt{ab} & \textbf{2}\\
\textbf{2} & \texttt{ab} & \textbf{2}\\
\textbf{1} & \texttt{ba} & \textbf{3}\\
\textbf{4} & \texttt{ba} & \textbf{3}\\
\textbf{3} & \texttt{bb} & \textbf{4}\\
\textbf{p} &  & \textbf{c}\\
\end{tabular}
\end{center}

Now, if, for example, we want to compare the strings \(abab\) and \(abba\). Divide them into two
halves and write the equivalence classes for each of the halves, get the pair \((2, 2)\) for the
string \(abab\), and the pair \((2, 3)\) for the string \(abba\). Now compare these pairs, we get that
\((2, 2) < (2, 3)\), which means that \(abab < abba\).

\subsection{Algorithm}
\label{sec:orgb47f146}
Thus, we get the following algorithm. First, we form strings of one character and sort them by
any sort algorithm in \(\mathcall{O}(n \log n)\). Next, \(\log n\) times we make the transition from
\(k\) to \(k + 1\). Each transition is done like this: take sorted strings of length \(2^k\), assign
equivalence classes to them, then assign to each string of length \(2^{k + 1}\) a pair of numbers:
equivalence classes of its halves, sort these pairs and get a sorted order for a string of length
\(2^{k + 1}\).

The time complexity this algorithm will be \(\mathcall{O}(n \log^2 n)\), because on at each of the
\(\log n\) iterations we do the sorting in \(\mathcall{O}(n \log n)\) time.
\end{document}